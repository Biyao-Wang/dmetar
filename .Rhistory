coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(), axis.title.x = element_text(color = "black",
size = 12, face = "bold"), axis.text.y = element_text(color = "black", size = 9 * text.scale),
plot.title = element_text(face = "bold", hjust = 0.5), axis.line.x = element_line(color = "black"),
axis.ticks.x = element_line(color = "black"), axis.text.x = element_text(color = "black", size = 9 *
text.scale)) + scale_y_continuous(trans = "log2", limits = c(min, max)) +
geom_rect(aes(ymin=plot.sum.lower, ymax=plot.sum.upper, xmin=0, xmax=Inf), alpha=0.08, fill="lightgreen", color=NA) + geom_hline(yintercept = plot.sum.effect, color = "darkgreen", linetype="dotted", size=0.5) + geom_pointrange()
} else if (class(x)[1] %in% c("metacor", "metaprop", "metarate")) {
effect = x$sm
n.studies = n.studies
# Create Sortdat data set for sorting
sortdat = data.frame(studlab = meta.inf$studlab, mean = meta.inf$TE, lower = meta.inf$lower,
upper = meta.inf$upper, i2 = meta.inf$I2)
sortdat2 = sortdat[1:(nrow(sortdat) - 2), ]
lastline = sortdat[nrow(sortdat), ]
# Change summary label
if (random == TRUE) {
lastline[1] = "Random-Effects Model"
} else {
lastline[1] = "Fixed-Effect Model"
}
for (i in 2:4) {
lastline[i] = format(round(lastline[i], 2), nsmall = 2)
}
# Sort
sortdat.es = sortdat2[order(sortdat2$mean), ]
sortdat.es = sortdat.es %>% mutate(studlab = forcats::fct_reorder(studlab, -mean))
sortdat.i2 = sortdat2[order(sortdat2$i2), ]
sortdat.i2 = sortdat.i2 %>% mutate(studlab = forcats::fct_reorder(studlab, -i2))
# Backtransform
backtransformer = function(x, sm, n){
# Define functions
z2cor = function(x)
{
res <- (exp(2 * x) - 1)/(exp(2 * x) + 1)
res
}
logit2p = function(x)
{
res <- 1/(1 + exp(-x))
res
}
asin2p = function (x, n = NULL, value = "mean", warn = TRUE)
{
if (all(is.na(x)))
return(x)
if (is.null(n)) {
minimum <- asin(sqrt(0))
maximum <- asin(sqrt(1))
}
else {
minimum <- 0.5 * (asin(sqrt(0/(n + 1))) + asin(sqrt((0 +
1)/(n + 1))))
maximum <- 0.5 * (asin(sqrt(n/(n + 1))) + asin(sqrt((n +
1)/(n + 1))))
}
sel0 <- x < minimum
sel1 <- x > maximum
if (any(sel0, na.rm = TRUE)) {
if (is.null(n)) {
if (warn)
warning("Negative value for ", if (length(x) >
1)
"at least one ", if (value == "mean")
"transformed proportion using arcsine transformation.\n  Proportion set to 0.",
if (value == "lower")
"lower confidence limit using arcsine transformation.\n  Lower confidence limit set to 0.",
if (value == "upper")
"upper confidence limit using arcsine transformation.\n  Upper confidence limit set to 0.",
sep = "")
}
else {
if (warn)
warning("Too small value for ", if (length(x) >
1)
"at least one ", if (value == "mean")
"transformed proportion using Freeman-Tukey double arcsine transformation.\n  Proportion set to 0.",
if (value == "lower")
"lower confidence limit using Freeman-Tukey double arcsine transformation.\n  Lower confidence limit set to 0.",
if (value == "upper")
"upper confidence limit using Freeman-Tukey double arcsine transformation.\n  Upper confidence limit set to 0.",
sep = "")
}
}
if (any(sel1, na.rm = TRUE)) {
if (is.null(n)) {
if (warn)
warning("Too large value for ", if (length(x) >
1)
"at least one ", if (value == "mean")
"transformed proportion using arcsine transformation.\n  Proportion set to 1.",
if (value == "lower")
"lower confidence limit using arcsine transformation.\n  Lower confidence limit set to 1.",
if (value == "upper")
"upper confidence limit using arcsine transformation.\n  Upper confidence limit set to 1.",
sep = "")
}
else {
if (warn)
warning("Too large value for ", if (length(x) >
1)
"at least one ", if (value == "mean")
"transformed proportion using Freeman-Tukey double arcsine transformation.\n  Proportion set to 1.",
if (value == "lower")
"lower confidence limit using Freeman-Tukey double arcsine transformation.\n  Lower confidence limit set to 1.",
if (value == "upper")
"upper confidence limit using Freeman-Tukey double arcsine transformation.\n  Upper confidence limit set to 1.",
sep = "")
}
}
res <- rep(NA, length(x))
sel <- !(sel0 | sel1)
sel <- !is.na(sel) & sel
res[sel0] <- 0
res[sel1] <- 1
if (is.null(n)) {
res[sel] <- sin(x[sel])^2
}
else {
res[sel] <- 0.5 * (1 - sign(cos(2 * x[sel])) * sqrt(1 -
(sin(2 * x[sel]) + (sin(2 * x[sel]) - 1/sin(2 * x[sel]))/n[sel])^2))
}
res
}
asin2ir = function (x, time = NULL, value = "mean", warn = TRUE)
{
if (all(is.na(x)))
return(x)
minimum <- 0.5 * (sqrt(0/time) + sqrt((0 + 1)/time))
sel0 <- x < minimum
if (any(sel0, na.rm = TRUE)) {
if (warn)
warning("Too small value for ", if (length(x) > 1)
"at least one ", if (value == "mean")
"transformed proportion using Freeman-Tukey double arcsine transformation.\n  Rate set to 0.",
if (value == "lower")
"lower confidence limit using Freeman-Tukey double arcsine transformation.\n  Lower confidence limit set to 0.",
if (value == "upper")
"upper confidence limit using Freeman-Tukey double arcsine transformation.\n  Upper confidence limit set to 0.",
sep = "")
}
res <- rep(NA, length(x))
sel <- !sel0
sel <- !is.na(sel) & sel
res[sel0] <- 0
res[sel] <- (1/time[sel] - 8 * x[sel]^2 + 16 * time[sel] *
x[sel]^4)/(16 * x[sel]^2 * time[sel])
res[res < 0] <- 0
res
}
if(sm == "COR"){
res = x
}
if(sm == "IR"){
res = x
}
if(sm == "PRAW"){
res = x
}
if(sm == "ZCOR"){
res = z2cor(x)
}
if(sm == "PLOGIT"){
res = logit2p(x)
}
if (sm == "PAS"){
res <- asin2p(x, value = value, warn = FALSE)
}
if (sm == "PFT"){
res = asin2p(x, n, value = value, warn = FALSE)
}
if (sm == "IRS"){
res = x^2
}
if (sm == "IRFT"){
res = asin2ir(x, time=n, value = value, warn = FALSE)
}
if (sm == "IRLN"){
res = exp(x)
}
if (sm == "PLN"){
res = exp(x)
}
res
}
if (class(x)[1] %in% c("metaprop", "metacor")){
n.h.m = meta.inf$n.harmonic.mean[1:(length(meta.inf$n.harmonic.mean)-2)]
n.h.m.tot = meta.inf$n.harmonic.mean[length(meta.inf$n.harmonic.mean)]
n.h.m.es = n.h.m[order(sortdat.es$mean)]
n.h.m.i2 = n.h.m[order(sortdat.i2$mean)]
sortdat.es$mean = backtransformer(sortdat.es$mean, sm=effect, n=n.h.m.es)
sortdat.es$lower = backtransformer(sortdat.es$lower, sm=effect, n=n.h.m.es)
sortdat.es$upper = backtransformer(sortdat.es$upper, sm=effect, n=n.h.m.es)
sortdat.i2$mean = backtransformer(sortdat.i2$mean, sm=effect, n=n.h.m.i2)
sortdat.i2$lower = backtransformer(sortdat.i2$lower, sm=effect, n=n.h.m.i2)
sortdat.i2$upper = backtransformer(sortdat.i2$upper, sm=effect, n=n.h.m.i2)
if (method.meta == "fixed"){
plot.sum.effect = backtransformer(x$TE.fixed, sm=effect, n=n.h.m.tot)
plot.sum.lower = backtransformer(x$lower.fixed, sm=effect, n=n.h.m.tot)
plot.sum.upper = backtransformer(x$upper.fixed, sm=effect, n=n.h.m.tot)
} else {
plot.sum.effect = backtransformer(x$TE.random, sm=effect, n=n.h.m.tot)
plot.sum.lower = backtransformer(x$lower.random, sm=effect, n=n.h.m.tot)
plot.sum.upper = backtransformer(x$upper.random, sm=effect, n=n.h.m.tot)
}
} else {
if(meta.inf$sm == "IRFT"){
n.h.m = meta.inf$t.harmonic.mean[1:(length(meta.inf$t.harmonic.mean)-2)]
n.h.m.es = n.h.m[order(sortdat.es$mean)]
n.h.m.i2 = n.h.m[order(sortdat.i2$mean)]
n.h.m.tot = meta.inf$t.harmonic.mean[length(meta.inf$t.harmonic.mean)]
sortdat.es$mean = backtransformer(sortdat.es$mean, sm=effect, n=n.h.m.es)
sortdat.es$lower = backtransformer(sortdat.es$lower, sm=effect, n=n.h.m.es)
sortdat.es$upper = backtransformer(sortdat.es$upper, sm=effect, n=n.h.m.es)
sortdat.i2$mean = backtransformer(sortdat.i2$mean, sm=effect, n=n.h.m.i2)
sortdat.i2$lower = backtransformer(sortdat.i2$lower, sm=effect, n=n.h.m.i2)
sortdat.i2$upper = backtransformer(sortdat.i2$upper, sm=effect, n=n.h.m.i2)
if (method.meta == "fixed"){
plot.sum.effect = backtransformer(x$TE.fixed, sm=effect, n=n.h.m.tot)
plot.sum.lower = backtransformer(x$lower.fixed, sm=effect, n=n.h.m.tot)
plot.sum.upper = backtransformer(x$upper.fixed, sm=effect, n=n.h.m.tot)
} else {
plot.sum.effect = backtransformer(x$TE.random, sm=effect, n=n.h.m.tot)
plot.sum.lower = backtransformer(x$lower.random, sm=effect, n=n.h.m.tot)
plot.sum.upper = backtransformer(x$upper.random, sm=effect, n=n.h.m.tot)
}
} else {
n.h.m.tot = meta.inf$n.harmonic.mean[length(meta.inf$n.harmonic.mean)]
sortdat.es$mean = backtransformer(sortdat.es$mean, sm=effect, n=NULL)
sortdat.es$lower = backtransformer(sortdat.es$lower, sm=effect, n=NULL)
sortdat.es$upper = backtransformer(sortdat.es$upper, sm=effect, n=NULL)
sortdat.i2$mean = backtransformer(sortdat.i2$mean, sm=effect, n=NULL)
sortdat.i2$lower = backtransformer(sortdat.i2$lower, sm=effect, n=NULL)
sortdat.i2$upper = backtransformer(sortdat.i2$upper, sm=effect, n=NULL)
if (method.meta == "fixed"){
plot.sum.effect = backtransformer(x$TE.fixed, sm=effect, n=n.h.m.tot)
plot.sum.lower = backtransformer(x$lower.fixed, sm=effect, n=n.h.m.tot)
plot.sum.upper = backtransformer(x$upper.fixed, sm=effect, n=n.h.m.tot)
} else {
plot.sum.effect = backtransformer(x$TE.random, sm=effect, n=n.h.m.tot)
plot.sum.lower = backtransformer(x$lower.random, sm=effect, n=n.h.m.tot)
plot.sum.upper = backtransformer(x$upper.random, sm=effect, n=n.h.m.tot)
}
}
}
# Generate Forest Plots
if (forest.lims[1] == "default") {
if (class(x)[1] == "metacor"){
min = min(sortdat.es$mean)-0.2
} else {
min = -0.2
}
max = max(sortdat.es$mean) + 0.5
} else {
min = forest.lims[1]
max = forest.lims[2]
}
# Set ggtitles
if (class(x)[1] == "metaprop"){
ggtitl = as.character("Proportion")
} else if (class(x)[1] == "metacor"){
ggtitl = as.character("Correlation")
} else {
ggtitl = as.character("Rate")
}
########################################
cat("===============")
########################################
forest.es = ggplot(sortdat.es, aes(x = studlab, y = mean, ymin = lower, ymax = upper)) + geom_pointrange() +
geom_text(aes(label = paste(format(round(mean, 2), nsmall = 2), " [", format(round(lower, 2),
nsmall = 2), ";", format(round(upper, 2), nsmall = 2), "] ", "; I2=", format(round(i2, 2),
nsmall = 2), sep = ""), y = Inf), hjust = "inward", size = 2 * text.scale) + geom_hline(yintercept = 0,
color = "blue") + ylab(paste(ggtitl, " (", as.character(lastline$studlab), ")", sep = "")) + ggtitle(paste("Sorted by",ggtitl)) +
coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(), axis.title.x = element_text(color = "black",
size = 12, face = "bold"), axis.text.y = element_text(color = "black", size = 9 * text.scale),
plot.title = element_text(face = "bold", hjust = 0.5), axis.line.x = element_line(color = "black"),
axis.ticks.x = element_line(color = "black"), axis.text.x = element_text(color = "black", size = 9 *
text.scale)) + scale_y_continuous(limits = c(min, max)) +
geom_rect(aes(ymin=plot.sum.lower, ymax=plot.sum.upper, xmin=0, xmax=Inf), alpha=0.08, fill="lightgreen", color=NA) + geom_hline(yintercept = plot.sum.effect, color = "darkgreen", linetype="dotted", size=0.5) + geom_pointrange()
forest.i2 = ggplot(sortdat.i2, aes(x = studlab, y = mean, ymin = lower, ymax = upper)) + geom_pointrange() +
geom_text(aes(label = paste("I2=", format(round(i2, 2), nsmall = 2), "; ", format(round(mean,
2), nsmall = 2), " [", format(round(lower, 2), nsmall = 2), ";", format(round(upper, 2), nsmall = 2),
"] ", sep = ""), y = Inf), hjust = "inward", size = 2 * text.scale) + geom_hline(yintercept = 0,
color = "blue") + ylab(paste(ggtitl, " (", as.character(lastline$studlab), ")", sep = "")) + ggtitle("Sorted by I-squared") +
coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(), axis.title.x = element_text(color = "black",
size = 12, face = "bold"), axis.text.y = element_text(color = "black", size = 9 * text.scale),
plot.title = element_text(face = "bold", hjust = 0.5), axis.line.x = element_line(color = "black"),
axis.ticks.x = element_line(color = "black"), axis.text.x = element_text(color = "black", size = 9 *
text.scale)) + scale_y_continuous(limits = c(min, max)) +
geom_rect(aes(ymin=plot.sum.lower, ymax=plot.sum.upper, xmin=0, xmax=Inf), alpha=0.08, fill="lightgreen", color=NA) + geom_hline(yintercept = plot.sum.effect, color = "darkgreen", linetype="dotted", size=0.5) + geom_pointrange()
} else {
# Create Sortdat data set for sorting
sortdat = data.frame(studlab = meta.inf$studlab, mean = meta.inf$TE, lower = meta.inf$lower, upper = meta.inf$upper,
i2 = meta.inf$I2)
sortdat2 = sortdat[1:(nrow(sortdat) - 2), ]
lastline = sortdat[nrow(sortdat), ]
# Change summary label
if (random == TRUE) {
lastline[1] = "Random-Effects Model"
} else {
lastline[1] = "Fixed-Effect Model"
}
for (i in 2:4) {
lastline[i] = format(round(lastline[i], 2), nsmall = 2)
}
# Sort
sortdat.es = sortdat2[order(sortdat2$mean), ]
sortdat.es = sortdat.es %>% mutate(studlab = forcats::fct_reorder(studlab, -mean))
sortdat.i2 = sortdat2[order(sortdat2$i2), ]
sortdat.i2 = sortdat.i2 %>% mutate(studlab = forcats::fct_reorder(studlab, -i2))
# Generate Forest Plots
if (forest.lims[1] == "default") {
min = round(min(sortdat.es$lower) - 0.1, 2)
max = round(max(sortdat.es$upper) + 0.3, 2)
} else {
min = forest.lims[1]
max = forest.lims[2]
}
if (method.meta == "fixed"){
plot.sum.effect = x$TE.fixed
plot.sum.lower = x$lower.fixed
plot.sum.upper = x$upper.fixed
} else {
plot.sum.effect = x$TE.random
plot.sum.lower = x$lower.random
plot.sum.upper = x$upper.random
}
########################################
cat("===============")
########################################
forest.es = ggplot(sortdat.es, aes(x = studlab, y = mean, ymin = lower, ymax = upper)) + geom_pointrange() +
geom_text(aes(label = paste(format(round(mean, 2), nsmall = 2), " [", format(round(lower, 2),
nsmall = 2), ";", format(round(upper, 2), nsmall = 2), "] ", "; I2=", format(round(i2, 2),
nsmall = 2), sep = ""), y = Inf), hjust = "inward", size = 2 * text.scale) + geom_hline(yintercept = 0,
color = "blue") + ylim(min, max) + ylab(paste("Effect Size (", as.character(lastline$studlab),
")", sep = "")) + ggtitle("Sorted by Effect Size") + coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(),
axis.title.x = element_text(color = "black", size = 12, face = "bold"), axis.text.y = element_text(color = "black",
size = 9 * text.scale), plot.title = element_text(face = "bold", hjust = 0.5), axis.line.x = element_line(color = "black"),
axis.ticks.x = element_line(color = "black"), axis.text.x = element_text(color = "black", size = 9 *
text.scale)) +
geom_rect(aes(ymin=plot.sum.lower, ymax=plot.sum.upper, xmin=0, xmax=Inf), alpha=0.08, fill="lightgreen", color=NA) + geom_hline(yintercept = plot.sum.effect, color = "darkgreen", linetype="dotted", size=0.5) + geom_pointrange()
forest.i2 = ggplot(sortdat.i2, aes(x = studlab, y = mean, ymin = lower, ymax = upper)) + geom_pointrange() +
geom_text(aes(label = paste("I2=", format(round(i2, 2), nsmall = 2), "; ", format(round(mean,
2), nsmall = 2), " [", format(round(lower, 2), nsmall = 2), ";", format(round(upper, 2), nsmall = 2),
"] ", sep = ""), y = Inf), hjust = "inward", size = 2) + geom_hline(yintercept = 0, color = "blue") +
ylim(min, max) + ylab(paste("Effect Size (", as.character(lastline$studlab), ")", sep = "")) +
ggtitle("Sorted by I-squared") + coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(),
axis.title.x = element_text(color = "black", size = 12, face = "bold"), axis.text.y = element_text(color = "black",
size = 9 * text.scale), plot.title = element_text(face = "bold", hjust = 0.5), axis.line.x = element_line(color = "black"),
axis.ticks.x = element_line(color = "black"), axis.text.x = element_text(color = "black", size = 9 *
text.scale)) +
geom_rect(aes(ymin=plot.sum.lower, ymax=plot.sum.upper, xmin=0, xmax=Inf), alpha=0.08, fill="lightgreen", color=NA) + geom_hline(yintercept = plot.sum.effect, color = "darkgreen", linetype="dotted", size=0.5) + geom_pointrange()
}
# Generate baujat plot Define baujat.silent
baujat.silent = function(x, yscale = 1, xlim, ylim, ...) {
TE = x$TE
seTE = x$seTE
TE.fixed = metagen(TE, seTE, exclude = x$exclude)$TE.fixed
k = x$k
studlab = x$studlab
SE = x$seTE
m.inf = metainf(x, pooled = "fixed")
TE.inf = m.inf$TE[1:length(TE)]
seTE.inf = m.inf$seTE[1:length(TE)]
ys = (TE.inf - TE.fixed)^2/seTE.inf^2
ys = ys * yscale
xs = (TE - TE.fixed)^2/seTE^2
if (!is.null(x$exclude))
xs[x$exclude] = 0
res = data.frame(studlab = studlab, x = xs, y = ys, se = SE)
return(res)
}
########################################
cat("===============")
########################################
bjt = baujat.silent(x)
BaujatPlot = ggplot(bjt, aes(x = x, y = y)) + geom_point(aes(size = (1/se)), color = "blue", alpha = 0.75) +
geom_rug(color = "lightgray", alpha = 0.5) + theme(legend.position = "none") + xlab("Overall hetereogeneity contribution") +
ylab("Influence on pooled result") + geom_label_repel(label = bjt$studlab, color = "black", size = 1.5 *
text.scale, alpha = 0.7)
# Return
if (return.seperate.plots == FALSE) {
# Combine
title = textGrob("Influence Diagnostics", gp = gpar(fontface = "bold"))
suppressWarnings(suppressMessages(gridExtra::grid.arrange(BaujatPlot, rma.influence.plot, forest.es,
forest.i2, nrow = 2, ncol = 2, widths = widths, heights = heights, top = title)))
########################################
cat("===============] DONE")
########################################
} else {
# Prepare data for return
return.data = cbind(sortdat2, cheungviechtdata[, 2:ncol(cheungviechtdata)], HetContrib = bjt$x, InfluenceEffectSize = bjt$y)
########################################
cat("===============] DONE \n")
########################################
if (x$sm %in% c("RR", "OR", "IRR")) {
colnames(return.data)[1:2] = c("Author", effect)
} else {
colnames(return.data)[1:2] = c("Author", "effect")
}
cat("When 'return.separate.plots' is set to 'TRUE', save the results of the influence_analysis function to an object and then access each plot with the '$' operator. Then use the object as an input to 'plot()'.")
suppressWarnings(suppressMessages(invisible(list(BaujatPlot = BaujatPlot, InfluenceCharacteristics = rma.influence.plot,
ForestEffectSize = forest.es, ForestI2 = forest.i2, Data = return.data))))
}
}
data(Olkin95)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95, subset = c(41, 47, 51, 59),
method = "Inverse")
InfluenceAnalysis(meta1)
devtools::load_all()
devtools::load_all()
data(Olkin95)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95, subset = c(41, 47, 51, 59),
method = "Inverse")
InfluenceAnalysis(meta1)
meta1
data(Olkin95)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95,
method = "Inverse")
InfluenceAnalysis(meta1)
data(Olkin95)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95,
method = "Inverse", subset=c(1:11, 58))
InfluenceAnalysis(meta1)
data(Olkin95)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95,
method = "Inverse", subset=c(1:11, 58))
InfluenceAnalysis(meta1)
InfluenceAnalysis(meta1, return.separate.plots = TRUE)
InfluenceAnalysis(meta1)
?metaprop
m2 <- metaprop(c(0, 0, 10, 10), rep(100, 4), incr=0.1)
InfluenceAnalysis(m2)
Olkin95$author[c(1:10,50)]
data(Olkin95)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95,
method = "Inverse", subset=c(1:10, 50),
studlab = Olkin95$author[c(1:10,50)])
InfluenceAnalysis(meta1)
metabin(event.e, n.e, event.c, n.c,
data = Olkin95,
method = "Inverse", subset=c(1:10, 50),
studlab = Olkin95$author[c(1:10,50)])
metabin(event.e, n.e, event.c, n.c,
data = Olkin95,
method = "Inverse", subset=c(1:10, 50),
studlab = Olkin95$author)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95,
method = "Inverse", subset=c(1:10, 50),
studlab = Olkin95$author)
InfluenceAnalysis(meta1)
data(Olkin95)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95,
method = "Inverse", sm="IRR", subset=c(1:11),
studlab = Olkin95$author)
InfluenceAnalysis(meta1)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95,
method = "Inverse", sm="ASD", subset=c(1:11),
studlab = Olkin95$author)
InfluenceAnalysis(meta1)
?metainc
m1 <- metainc(d.smokers, py.smokers,
d.nonsmokers, py.nonsmokers,
data=smoking, studlab=study)
InfluenceAnalysis(m1)
data(smoking)
m1 <- metainc(d.smokers, py.smokers,
d.nonsmokers, py.nonsmokers,
data=smoking, studlab=study)
InfluenceAnalysis(m1)
InfluenceAnalysis(m1, forest.lims = c(0.8,2.5))
m1 <- metainc(d.smokers, py.smokers,
d.nonsmokers, py.nonsmokers,
data=smoking, studlab=study)
InfluenceAnalysis(m1, forest.lims = c(1.5,2.5))
m1
devtools::check()
devtools::spell_check()
install.packages("spelling")
devtools::spell_check()
pkgdown::build_site()
devtools::load_all()
InfluenceAnalysis(meta1)
?metabin
data(Olkin95)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95, subset = c(41, 47, 51, 59),
method = "Inverse")
InfluenceAnalysis(meta1)
data(Olkin95)
meta1 <- metabin(event.e, n.e, event.c, n.c,
data = Olkin95, subset = c(1:5,41, 47, 51, 59),
method = "Inverse")
InfluenceAnalysis(meta1)
citation(lme4)
citation("lme4")
citation("mitml")
citation("dmetar")
citation("R")
devtools::build_manual()
devtools::build_manual()
devtools::build_site()
devtools::build_site()
devtools::build_manual()
